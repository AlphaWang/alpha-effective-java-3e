# Item 47: Prefer Collection to Stream as a return type

## We don't do this much.....but

```java
   // Won't compile, due to limitations on Java's type inference
for (ProcessHandle ph : ProcessHandle.allProcesses()::iterator) { // Process the process
}
^Test.java:6: error: method reference not expected here
for (ProcessHandle ph : ProcessHandle.allProcesses()::iterator) {
```
- Can use forEach loop <-> Collection extends iterable interface
- But Stream didn't extend iterable, So you need to cast iterator to iterable
- However, Method reference is not allowed in there

```java
   // Adapter from  Stream<E> to Iterable<E>
   // It implicitly casts Stream.iterator to Iterable.. Let's see magic happen
   public static <E> Iterable<E> iterableOf(Stream<E> stream) {
       return stream::iterator;
}

  //Above came from this snippet
     public static <E> Iterable<E> iterableOf(Stream<E> stream) {
         return new Iterable<E>() { 
         			@NotNull
         			@Override
         			public Iterator<E> iterator() { //it looks like functional interface like Supplier<Iterator<E>>
         				return stream.iterator();
         			}
         		};
  }
  
  //it's same as above
  public static <E> Iterable<E> iterableOf(Stream<E> stream) {
  		Iterable<E> iterable =  () -> stream.iterator(); 
  		return iterable;
  	}
  	
  //Applying method reference, boom!
     public static <E> Iterable<E> iterableOf(Stream<E> stream) {
         return stream::iterator;
  }
```

```java
// Adapter from Iterable<E> to Stream<E>
   public static <E> Stream<E> streamOf(Iterable<E> iterable) {
       return StreamSupport.stream(iterable.spliterator(), false); //it is not parallel
}
```

- You have to provide this helper methods for anyone... : frustrated
- Collection interface implements Iterable and Stream, So just return Collection
- But Collection is eagerly working, don't put enormous eggs in a bucket -> Memory Boom! + Size() overflow (size is int)

### If the sequence youâ€™re returning is large but can be represented concisely, con- sider implementing a special-purpose collection

- Power Set : powerSet({a,b,c}) == {{},{a},{b},{c},{a,b},{a,c},{b,c},{a,b,c}}, every subset of given set. If Size of given set X is n, size of powerSet(X) is 2^n

```java
	public class PowerSet {
		public static final <E> Collection<Set<E>> of(Set<E> s) {
			List<E> src = new ArrayList<>(s);
			if (src.size() > 30)
				throw new IllegalArgumentException("Set too big " + s);
			return new AbstractList<Set<E>>() {
				@Override
				public int size() {
					return 1 << src.size(); // 2 to the power srcSize
				}

				@Override
				public boolean contains(Object o) {
					return o instanceof Set && src.containsAll((Set) o);
				}

				@Override
				public Set<E> get(int index) {
					Set<E> result = new HashSet<>();
					for (int i = 0; index != 0; i++, index >>= 1)
						if ((index & 1) == 1)
							result.add(src.get(i));
					return result;
				}
			};
		}
	}
```
- powerSet.get(index) returns index-th power set : 
  - if index is 7, it's bit representation is 1101 which means it returns set contains 0-th element, 2-th element, 3-th element.
  - if index is 0, it's bit representation is 0 which means it returns empty set
  - if index is equal to size of powerSet of given Set X, it returns given set X itself
- Size of given Set X is bound to 30, because size() is signed integer and it's maximum value is 2^31-1 so when size of given Set X is 31 and size of powerSet(x) is 2^31, the  overflow happens.

```java
   public class SubLists {
      public static <E> Stream<List<E>> of(List<E> list) {
         return Stream.concat(Stream.of(Collections.emptyList()),
            prefixes(list).flatMap(SubLists::suffixes)); 
      }
      private static <E> Stream<List<E>> prefixes(List<E> list) {
         return IntStream.rangeClosed(1, list.size())
            .mapToObj(end -> list.subList(0, end));
      }
   private static <E> Stream<List<E>> suffixes(List<E> list) {
      return IntStream.range(0, list.size())
         .mapToObj(start -> list.subList(start, list.size()));
       }
   }
   
```

- Prefix([a,b,c]) = [a,[a,b],[a,b,c]] : Every sublists contains first element
- Suffix([a,b,c]) = [c,[b,c],[a,b,c]] : Every sublists contains last element
- Sublist[a,b,c]) = [a,b,c,[a,b],[b,c],[a,b,c]] : Lists contains part of element of given List X orderly and contiguously 
- Suffix(Prefix(X)) = Every sublists of X 
- Intuition doesn't work, Why?
  - Prefix(Suffix(X)) contains all sublists of X : Let's assume a sublist A of X was not generated by this process, because A is sublist of X, A have part of X with orderly and contiguously.
    - Let X[i] means i-th element of given List X with size n
    - A.concat(X[j],X[j+1]....X[n-1]) = A' is included in Suffix of X (0 < j < n-1)
    - Prefix of Some suffix is sublist, because it is contiguously and consists of elements in list X and orderly. What we want to know is if it generated all sublists possible. 
    - Because A' is included in Suffix of X, A's prefixes are also included in sublist
    - A's prefix includes A itself, So A is included in sublists of X
    - It is contradiction of statement that A is not included in sublists of X by given process
    - So A is included in sublists of X with given process. 

### Return collection always. User may want to iterate over them. If it is too big to accommodate in Collection, Implement Your own Collection. If it is not easy, Consider Returning Stream or Iterable. Stream in future java will implement iterable, so deal with it until then.